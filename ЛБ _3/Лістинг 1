def swap(arr, i, j): 

    """Міняє місцями два елементи в масиві.""" 

    arr[i], arr[j] = arr[j], arr[i] 

  

  

def sink(arr, i, n): 

    """ 

    Процедура 'занурення' елемента вниз по купі. 

    arr: масив 

    i: індекс поточного елемента 

    n: розмір купи 

    """ 

    k = i 

    while True: 

        j = 2 * k + 1  # Індекс лівого дочірнього елемента 

        if j >= n: 

            break 

  

        # Знаходимо індекс найбільшого дочірнього елемента 

        if j + 1 < n and arr[j + 1] > arr[j]: 

            j += 1 

  

        # Якщо поточний елемент більший або дорівнює найбільшому дочірньому 

        if arr[k] >= arr[j]: 

            break 

  

        # Міняємо місцями та продовжуємо занурення 

        swap(arr, k, j) 

        k = j 

  

  

def heapsort(arr): 

    """ 

    Алгоритм пірамідального сортування. 

    """ 

    n = len(arr) 

    print(f"Початковий масив: {arr}\n") 

  

    # Фаза 1: Побудова максимальної купи 

    print("--- Фаза 1: Побудова максимальної купи ---") 

    for i in range(n // 2 - 1, -1, -1): 

        print(f"Занурюємо елемент з індексу {i}: {arr[i]}") 

        sink(arr, i, n) 

  

    print(f"\nМасив після побудови купи: {arr}\n") 

  

    # Фаза 2: Сортування 

    print("--- Фаза 2: Сортування ---") 

    for i in range(n - 1, 0, -1): 

        # Переносимо найбільший елемент (корінь) в кінець 

        print(f"Міняємо місцями корінь ({arr[0]}) та останній елемент ({arr[i]})") 

        swap(arr, 0, i) 

  

        # Зменшуємо розмір купи та відновлюємо її властивості 

        n -= 1 

        print(f"Розмір купи зменшився до {n}. Відновлюємо властивості купи.") 

        sink(arr, 0, n) 

        print(f"Масив на поточному кроці: {arr}\n") 

  

    return arr 

  

  

# --- Моделювання --- 

A = [58, 5, 50, 99, 61, 32, 27, 45, 75] 

sorted_A = heapsort(A) 

print(f"Відсортований масив: {sorted_A}") 

 
